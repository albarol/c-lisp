
(load "stl/prelude.clisp")
(load "stl/unittest.clisp")

(test-suite "Prelude suite case")

; Math
(test-case "test pi" (check-eq? (pi) 3.1415 "Pi should be 3.1415"))
(test-case "test add1" (check-eq? (add1 1) 2 "Should be 2"))
(test-case "test sub1" (check-eq? (sub1 1) 0 "Should be 0"))
(test-case "test sign negative" (check-eq? (sign -3) -1 "should be -1"))
(test-case "test sign positive" (check-eq? (sign 3) 1 "should be 1"))
(test-case "test sign zero" (check-eq? (sign 0) 0 "should be 0"))
(test-case "test double" (check-eq? (double 3) 6 "should be 6"))
(test-case "test triple" (check-eq? (triple 3) 9 "should be 9"))
(test-case "test fib" (check-eq? (map fib (range 1 4)) [1 1 2 3] "should be [1 1 2 3]"))
(test-case "test fact" (check-eq? (map fact (range 1 4)) [1 2 6 24] "should be [1 2 6 24]"))

; List
(test-case "test reverse empty" (check-eq? (reverse []) [] "should be empty"))
(test-case "test reverse" (check-eq? (reverse (range 1 4)) [4 3 2 1] "should be [4 3 2 1]"))
(test-case "test nth empty" (check-eq? (nth 3 []) [] "should be []"))
(test-case "test nth not exists" (check-eq? (nth 3 [1 2]) [] "should be []"))
(test-case "test nth" (check-eq? (nth 3 [1 2 3 4]) 3 "should be 3"))
(test-case "test last" (check-eq? (last (range 1 10)) 10 "should be 10"))
(test-case "test first" (check-eq? (first (range 1 10)) 1 "should be 1"))
(test-case "test remove" (check-eq? (remove 3 (range 1 10)) [1 2 4 5 6 7 8 9 10] "should be [1 2 4 5 6 7 8 9 10]"))

(test-case "test map empty" (check-eq? (map double []) [] "should be empty"))
(test-case "test map" (check-eq? (map double (range 1 4)) [2 4 6 8] "should be [2 4 6 8]"))
(test-case "test fold empty" (check-eq? (fold double 0 []) 0 "should be 0"))
(test-case "test fold" (check-eq? (fold * 1 (range 1 3)) 6 "should be 6"))
(test-case "test reduce empty" (check-error? (reduce double []) "should be 0"))
(test-case "test reduce" (check-eq? (reduce + (range 1 4)) 10 "should be 10"))
(test-case "test filter empty" (check-eq? (filter (fn (t) (> 5 t)) []) [] "should be []"))
(test-case "test filter" (check-eq? (filter (fn (t) (> t 5)) (range 1 10)) [6 7 8 9 10] "should be [6 7 8 9 10]"))

(test-case "test flatten empty" (check-eq? (flatten []) [] "should be []"))
(test-case "test flatten" (check-eq? (flatten [1 2 3 [4 [5 6] 7] 8 9]) [1 2 3 4 5 6 7 8 9] "should be [1 2 3 4 5 6 7 8 9]"))
(test-case "test zip xs empty" (check-eq? (zip [] [1 2]) [] "should be []"))
(test-case "test zip ys empty" (check-eq? (zip [1 2] []) [] "should be []"))
(test-case "test zip" (check-eq? (zip [1 2] [3 4]) [[1 3] [2 4]] "should be [[1 3] [2 4]]"))

(test-case "test range start > end" (check-eq? (range 10 1) [] "should be []"))
(test-case "test range" (check-eq? (range 1 10) [1 2 3 4 5 6 7 8 9 10] "should be [1 2 3 4 5 6 7 8 9 10]"))
(test-case "test repeat" (check-eq? (repeat 1 5) [1 1 1 1 1] "should be [1 1 1 1 1]"))
(test-case "test all true" (check-true? (all [#t #t #t]) "should be #t"))
(test-case "test all false" (check-false? (all [#t #f #t]) "should be #f"))
(test-case "test any true" (check-true? (any [#t #f #t]) "should be #t"))
(test-case "test any false" (check-false? (any [#f #f #f]) "should be #f"))

(test-case "test take empty" (check-eq? (take 3 []) [] "should be []"))
(test-case "test take < total" (check-eq? (take 3 [1 2]) [1 2] "should be [1 2]"))
(test-case "test take" (check-eq? (take 3 [1 2 3 5 6 4]) [1 2 3] "should be [1 2 3]"))
(test-case "test drop empty" (check-eq? (drop 3 []) [] "should be []"))
(test-case "test drop < total" (check-eq? (drop 3 [1 2]) [] "should be [1 2]"))
(test-case "test drop" (check-eq? (drop 3 [1 2 3 5 6 4]) [5 6 4] "should be [5 6 4]"))
(test-case "test takeWhile empty" (check-eq? (takeWhile (fn (t) (> 5 t)) []) [] "should be []"))
(test-case "test takeWhile stop iteration" (check-eq? (takeWhile (fn (t) (< t 5)) [1 2 3 5 6 4]) [1 2 3] "should be [1 2 3]"))
(test-case "test takeWhile" (check-eq? (takeWhile (fn (t) (<= t 5)) (range 1 10)) [1 2 3 4 5] "should be [1 2 3 4 5]"))
(test-case "test dropWhile empty" (check-eq? (dropWhile (fn (t) (> 5 t)) []) [] "should be []"))
(test-case "test dropWhile stop iteration" (check-eq? (dropWhile (fn (t) (<= t 5)) [1 2 6 7 8 3 9]) [6 7 8 3 9] "should be [6 7 8 3 9]"))
(test-case "test dropWhile" (check-eq? (dropWhile (fn (t) (< t 5)) (range 1 10)) [5 6 7 8 9 10] "should be [5 6 7 8 9 10]"))
(test-case "test takeFirst empty" (check-eq? (takeFirst (fn (t) (> 3)) []) [] "should be []"))
(test-case "test takeFirst" (check-eq? (takeFirst (fn (t) (> t 3)) (range 1 10)) 4 "should be 4"))
(test-case "test takeLast empty" (check-eq? (takeLast (fn (t) (> 3)) []) [] "should be []"))
(test-case "test takeLast" (check-eq? (takeLast (fn (t) (> t 3)) (range 1 10)) 10 "should be 10"))

(test-case "test slice empty" (check-eq? (slice 1 10 []) [] "should be []"))
(test-case "test slice" (check-eq? (slice 1 3 (range 1 10)) [2 3 4] "should be [2 3 4]"))

(test-case "test sum" (check-eq? (sum (range 1 10)) 55 "should be 55"))
(test-case "test multiply" (check-eq? (multiply (range 1 4)) 24 "should be 24"))
(test-case "test max" (check-eq? (max (range 1 10)) 10 "should be 10"))
(test-case "test min" (check-eq? (min (range 1 10)) 1 "should be 1"))

